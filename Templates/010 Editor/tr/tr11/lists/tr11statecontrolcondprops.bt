string GetStateControlConditionPropertyName(int condition)
{
    switch (condition)
    {
        case 0x0: return "Unknown";
        case 0x1: return "Always";
        case 0x2: return "SCProperty_Boolean";
        case 0x3: return "SCProperty_Numeric";
        case 0x4: return "JumpMode";
        case 0x5: return "Frames_InState";
        case 0x6: return "Frames_Unbalanced";
        case 0x7: return "Frames_SinceRunning";
        case 0x8: return "Frames_UntilMarkupAttach";
        case 0x9: return "Frames_OnSlopeSlide";
        case 0xA: return "Frames_OnGrapple";
        case 0xB: return "Frames_OnRope";
        case 0xC: return "Frames_InAir";
        case 0xD: return "Frames_InMeleeMove";
        case 0xE: return "Frames_InStateHosted";
        case 0xF: return "Frames_AtMoveSpeed";
        case 0x10: return "Frames_AtMoveDir";
        case 0x11: return "Frames_AtMoveSpeedAndDir";
        case 0x12: return "Frames_SinceLowCeiling";
        case 0x13: return "Frames_InState_or_Anim_Ended";
        case 0x14: return "Frames_InState_or_Anim_CriticalSectionDone";
        case 0x15: return "Frames_SinceInteractEnd";
        case 0x16: return "Frames_SinceLastZipline";
        case 0x17: return "Distance_Fallen";
        case 0x18: return "Jump_TakeoffHeightDelta";
        case 0x19: return "Jump_TakeoffXYDelta";
        case 0x1A: return "Distance_ZDelta";
        case 0x1B: return "Distance_VertDynoClearance";
        case 0x1C: return "Distance_ToCombatTarget_Within";
        case 0x1D: return "Distance_InAirToWaterHitLessThan";
        case 0x1E: return "Distance_ToAnimTargetScriptedInstance_Within";
        case 0x1F: return "Distance_MeleeTargetToAnimTargetScriptedInstance_Within";
        case 0x20: return "Status_IsAssigned_AnimTargetScriptedInstance";
        case 0x21: return "MeleeTarget_FacingAngle_Within";
        case 0x22: return "Status_CameraFinalYawVersusPlayerYawLessThan";
        case 0x23: return "Internal_HasQueuedTrans";
        case 0x24: return "Requested";
        case 0x25: return "Held_FlairTime";
        case 0x26: return "Held_GamePlayTimeLimit";
        case 0x27: return "TimeSincePressedLessThanFramesInState";
        case 0x28: return "TimeSincePressedLessThanFramesInAir";
        case 0x29: return "TimeSincePressedLessThanFramesInWater";
        case 0x2A: return "TimeSincePressedLessThanLimit";
        case 0x2B: return "TimeSinceReleasedLessThanLimit";
        case 0x2C: return "TimeSincePressedLessThanLimit2";
        case 0x2D: return "TimeSinceReleasedLessThanLimit2";
        case 0x2E: return "TimeSincePressedIsZero";
        case 0x2F: return "TimeSinceReleasedIsZero";
        case 0x30: return "HurdleOptionNewlyPressed";
        case 0x31: return "AnalogReleaseRateLessThanLimit";
        case 0x32: return "AnalogPressRateLessThanLimit";
        case 0x33: return "AnalogReleaseRateMoreThanLimit";
        case 0x34: return "AnalogPressRateMoreThanLimit";
        case 0x35: return "AnalogAmountMoreThanLimit";
        case 0x36: return "AnalogAmountLessThanLimit";
        case 0x37: return "AnalogPressedCompletely";
        case 0x38: return "AnalogReleasedCompletely";
        case 0x39: return "AnalogPressed";
        case 0x3A: return "ActiveAttach_Requested";
        case 0x3B: return "ActiveAttach_RequestedForWallCrawl";
        case 0x3C: return "Anim_Ended";
        case 0x3D: return "Anim_CriticalSection";
        case 0x3E: return "Anim_CriticalSectionOnAnyProcessor";
        case 0x3F: return "Anim_Transitioning";
        case 0x40: return "Anim_TransitioningProcessor0";
        case 0x41: return "Anim_TransitioningProcessor1";
        case 0x42: return "Anim_Mirrored";
        case 0x43: return "Anim_TorsoAllowed";
        case 0x44: return "Anim_FrameCountEquals";
        case 0x45: return "Anim_FrameCountAtOrMore";
        case 0x46: return "Anim_FrameCountAtOrLess";
        case 0x47: return "Anim_FrameCountFromEndIsLessThan";
        case 0x48: return "Anim_FrameCountPercentageAtOrMore";
        case 0x49: return "Anim_FrameCountPercentageAtOrLess";
        case 0x4A: return "SwimClimboutFrameCounterElapsed";
        case 0x4B: return "Anim_AnimTargetingEnded";
        case 0x4C: return "Anim_AnimCompleteID";
        case 0x4D: return "JumpTime_FrameCountEquals";
        case 0x4E: return "JumpTime_FrameCountAtOrMore";
        case 0x4F: return "JumpTime_FrameCountAtOrLess";
        case 0x50: return "Foot_Supported";
        case 0x51: return "Foot_Locked";
        case 0x52: return "Foot_WantsToLock";
        case 0x53: return "Foot_LockBroken";
        case 0x54: return "Foot_LockFailed";
        case 0x55: return "Move_Speed";
        case 0x56: return "Move_Direction";
        case 0x57: return "Move_DirFromTarget";
        case 0x58: return "Move_DirFromMeleeTarget";
        case 0x59: return "Move_DirLeftOrRight";
        case 0x5A: return "Move_FacingZone";
        case 0x5B: return "Move_DirMomentum";
        case 0x5C: return "Move_DirDownhill";
        case 0x5D: return "Move_DirUnbalanced";
        case 0x5E: return "Move_FacingDirFromTarget";
        case 0x5F: return "Move_FacingDirFromJumpTarget";
        case 0x60: return "Move_FacingDirFromCoverTarget";
        case 0x61: return "Move_FacingDirFromCamera";
        case 0x62: return "Move_DirFromJumpTarget";
        case 0x63: return "Move_DirFromCoverTarget";
        case 0x64: return "Move_DirFromJumpTargetMarkupDirection";
        case 0x65: return "Move_DirFromJumpTargetMarkupDirectionExact";
        case 0x66: return "Move_DirTowardJumpTarget";
        case 0x67: return "Move_CachedDirection";
        case 0x68: return "Move_DirFromJumpTargetMarkupNormal";
        case 0x69: return "Move_DirLeftOrRightFromJumpTargetMarkupNormal";
        case 0x6A: return "Move_DirFromAttachedMarkupNormal";
        case 0x6B: return "Move_DirLeftOrRightFromAttachedMarkupNormal";
        case 0x6C: return "Move_FacingDirFromJumpTargetMarkupNormal";
        case 0x6D: return "Move_FacingDirLeftOrRightFromJumpTargetMarkupNormal";
        case 0x6E: return "Move_FacingDirFromAttachedMarkupNormal";
        case 0x6F: return "Move_FacingDirLeftOrRightFromAttachedMarkupNormal";
        case 0x70: return "Move_CachedSpeed";
        case 0x71: return "Move_CachedDirFromTarget";
        case 0x72: return "Move_FacingDirFromJumpTargetMarkupDirection";
        case 0x73: return "Move_DirFromWallCrawlPoint";
        case 0x74: return "Move_DirFromWallCrawlNormal";
        case 0x75: return "Move_DirFromRappelClimb";
        case 0x76: return "Move_DirFromMarkupPath";
        case 0x77: return "Move_FacingDirFromMarkupPath";
        case 0x78: return "Move_StickAngleGreaterThan";
        case 0x79: return "Move_StickAngleLessThan";
        case 0x7A: return "Move_StickAngleEqual";
        case 0x7B: return "Move_StickAngleDeltaAtLeast";
        case 0x7C: return "Move_FacingDirFromAttachedMarkupDirection";
        case 0x7D: return "Move_FacingDirFromAttachedMarkupDirectionExact";
        case 0x7E: return "Move_FacingDirFromAttachedRopeDirection";
        case 0x7F: return "Move_FacingDirFromAttachedMarkup";
        case 0x80: return "Move_BallisticSpeedAtLeast";
        case 0x81: return "Move_VelocityAtLeast";
        case 0x82: return "Move_ForwardVelocityAtLeast";
        case 0x83: return "Move_DesiredVelocityAtLeast";
        case 0x84: return "Move_DirFromSteeringGoal";
        case 0x85: return "Move_DirFromOriginalSteeringGoal";
        case 0x86: return "Move_SpeedLimitMultPercentAtLeast";
        case 0x87: return "Move_SteeringDirFromFacing";
        case 0x88: return "Move_DirFromEdge";
        case 0x89: return "Move_CameraDirFromAttachedMarkup";
        case 0x8A: return "MovesetProfile_IsMoveAllowed";
        case 0x8B: return "Move_SteeringDirToFacingDirAngleGTE";
        case 0x8C: return "Hurdle_Outcome";
        case 0x8D: return "Vehicle_SubmergedDepth";
        case 0x8E: return "Vehicle_YawPitch";
        case 0x8F: return "Vehicle_State";
        case 0x90: return "Vehicle_StuntDirection";
        case 0x91: return "Vehicle_JumpDismount";
        case 0x92: return "Vehicle_InAir";
        case 0x93: return "Vehicle_SecondaryBrake";
        case 0x94: return "Vehicle_SteerDirection";
        case 0x95: return "Vehicle_IdlePose";
        case 0x96: return "Vehicle_JumpDismountReverse";
        case 0x97: return "Vehicle_PhysicsImpact";
        case 0x98: return "Vehicle_SpeedBurst";
        case 0x99: return "Gymnastics_IsValidTrans";
        case 0x9A: return "Vehicle_DismountClearance";
        case 0x9B: return "Edge_Detected";
        case 0x9C: return "Edge_InMoveDir";
        case 0x9D: return "Edge_DropToWater";
        case 0x9E: return "Edge_DropToSlope";
        case 0x9F: return "Edge_DropToFlooring";
        case 0xA0: return "Edge_MarkupMod";
        case 0xA1: return "Edge_DropDistance";
        case 0xA2: return "Edge_DistanceFromEdge";
        case 0xA3: return "LineProbeCollided";
        case 0xA4: return "Status_InWater";
        case 0xA5: return "Status_InAir";
        case 0xA6: return "Status_InAir_JumpingIntoWater";
        case 0xA7: return "Status_LowCeiling";
        case 0xA8: return "Status_IsFalling";
        case 0xA9: return "Status_FallFacesAwayFromCamera";
        case 0xAA: return "Status_InCombatMode";
        case 0xAB: return "Status_UsingGear";
        case 0xAC: return "Status_AttachIntoSwing";
        case 0xAD: return "Status_OnSlopeSlide";
        case 0xAE: return "Status_ProxySupported";
        case 0xAF: return "Status_GroundAhead";
        case 0xB0: return "Status_UnbalancedFall";
        case 0xB1: return "Status_OnGround";
        case 0xB2: return "Status_JustLanded";
        case 0xB3: return "Status_WallJumpAttach";
        case 0xB4: return "Status_IsMantleComing";
        case 0xB5: return "Status_CanSprint";
        case 0xB6: return "Status_IsWallSlide";
        case 0xB7: return "Status_IsInCheatMode";
        case 0xB8: return "Status_OnStairs";
        case 0xB9: return "Status_DoFallTargeting";
        case 0xBA: return "Status_WallJumpAnticipate";
        case 0xBB: return "Status_VelocityDownward";
        case 0xBC: return "Status_InAccurateAim";
        case 0xBD: return "Status_HolsterTimerElapsed";
        case 0xBE: return "Status_WindupTimerElapsed";
        case 0xBF: return "Status_LineProbeHitLastTime";
        case 0xC0: return "Status_WallHPoleRightTransition";
        case 0xC1: return "Status_WallHPoleLeftTransition";
        case 0xC2: return "Status_IsSwimming";
        case 0xC3: return "Status_IsMovingAlongMarkup";
        case 0xC4: return "Status_CameraRotAboutWorldXGreaterThan";
        case 0xC5: return "Status_CameraRotAboutWorldXLessThan";
        case 0xC6: return "Status_CameraHorizTruckGreaterThan";
        case 0xC7: return "Status_CameraHorizTruckLessThan";
        case 0xC8: return "Status_Camera_HasScriptedLookAtInstance";
        case 0xC9: return "Status_Camera_HasScriptedLookAtInstance_Forced";
        case 0xCA: return "Status_Camera_HasScriptedLookAtInstance_MovementDisabled";
        case 0xCB: return "Status_Camera_InScriptedLookAtState_ReachedTimeOut";
        case 0xCC: return "Status_UI_IsStatusMenuFullscreen";
        case 0xCD: return "Status_UI_IsJustClosed";
        case 0xCE: return "Status_BodyDrag";
        case 0xCF: return "Status_WallJumpCollide";
        case 0xD0: return "Status_ScreenSpaceInputPassedAngThreshold";
        case 0xD1: return "Status_CanDodge";
        case 0xD2: return "Status_ShouldDie";
        case 0xD3: return "Status_ScriptContextualAnimAllowed";
        case 0xD4: return "Status_WallJumpAllowed";
        case 0xD5: return "Status_SprintAllowed";
        case 0xD6: return "Status_ProxyCollidingWithTerrain";
        case 0xD7: return "Status_ProxyCollidingWithTerrainHeadOn";
        case 0xD8: return "Status_WallOrEdgeStop";
        case 0xD9: return "Status_WallOrEdgeStopCached";
        case 0xDA: return "Status_WallOrEdgeStopAndCover";
        case 0xDB: return "Status_WallOrEdgeStopCachedAndCover";
        case 0xDC: return "Status_WallOrEdgeStopDetectsWall";
        case 0xDD: return "Status_WallOrEdgeStopDetectsEdge";
        case 0xDE: return "Status_JumpTargetInEdgeDirection";
        case 0xDF: return "Status_PotentialTargetInEdgeDirection";
        case 0xE0: return "Status_ProxyCollidingWithNoPlayerResponse";
        case 0xE1: return "Status_CameraUpPlayerForwardProjWorldXYAngleLessThan";
        case 0xE2: return "Status_VelocityBallisticIsZero";
        case 0xE3: return "Status_IsVertJump";
        case 0xE4: return "Status_NonWallCrawlAttach";
        case 0xE5: return "Status_WallCrawlAttach";
        case 0xE6: return "Status_WallCrawlWillAttach";
        case 0xE7: return "Status_WallCrawlBlocked";
        case 0xE8: return "Status_WallCrawlInclinedIsAttached";
        case 0xE9: return "Status_WallCrawlInclinedWasAttached";
        case 0xEA: return "Status_IsWallCrawlAttachTargetInclinedNow";
        case 0xEB: return "Status_IsWallCrawlAttachTargetInclined";
        case 0xEC: return "Status_WallCrawlIsAttached";
        case 0xED: return "Status_WallCrawlFootAttach";
        case 0xEE: return "Status_WallCrawlHandAttach";
        case 0xEF: return "Status_RappelInitiateFromWallCrawl";
        case 0xF0: return "Status_StepBackIntoCover";
        case 0xF1: return "Status_StepBackIntoCoverFromAim";
        case 0xF2: return "Status_CanAttachToWallCrawlFromRope";
        case 0xF3: return "Status_ZiplineEndsInWallCrawl";
        case 0xF4: return "Status_Prototype_IsHunted";
        case 0xF5: return "Status_CanConceal";
        case 0xF6: return "Status_IsConcealed";
        case 0xF7: return "Status_CanRoll";
        case 0xF8: return "Status_CanDeathFromAbove";
        case 0xF9: return "Status_InCover";
        case 0xFA: return "Status_InCoverCrouched";
        case 0xFB: return "Status_IsInjured";
        case 0xFC: return "Status_IsDrowning";
        case 0xFD: return "Status_IsHoldingBreath";
        case 0xFE: return "Status_IsUnderwater";
        case 0xFF: return "Status_AllPlayersAreDead";
        case 0x100: return "Status_IsStandingOnRollyBall";
        case 0x101: return "Status_Move_Omnidirectional";
        case 0x102: return "Status_Move_Omnidirectional_Allowed";
        case 0x103: return "Status_IsStaffActive";
        case 0x104: return "Status_IsPlayerAlive";
        case 0x105: return "Status_IsPlayerConcealed";
        case 0x106: return "Status_IsPlayerCamouflaged";
        case 0x107: return "Status_IsPlayerUsingFinisher";
        case 0x108: return "Status_IsParagliding";
        case 0x109: return "Status_IsParaglidingPossible";
        case 0x10A: return "Status_IsParaglidingStabilized";
        case 0x10B: return "Status_HeadTrackFullbodyTurnRequired";
        case 0x10C: return "Combat_ActionPressedWithinMeleeInputWatchWindow";
        case 0x10D: return "Combat_CutActionPressedWithinCutVegetationWatchWindow";
        case 0x10E: return "Combat_IsInMeleeArmorHitReactState";
        case 0x10F: return "Combat_IsMeleeCharging";
        case 0x110: return "Markup_JumpTargetType";
        case 0x111: return "Markup_JumpTargetHasCamouflageConcealment";
        case 0x112: return "Markup_AttachedType";
        case 0x113: return "Markup_AttachedHasDynamicMarkupComponentNotConnected";
        case 0x114: return "Markup_RescueTargetType";
        case 0x115: return "Markup_PotentialJumpTargetType";
        case 0x116: return "Markup_GrappleJumpTargetType";
        case 0x117: return "Markup_ConcealmentMarkupType";
        case 0x118: return "Markup_GrappleTargetReached";
        case 0x119: return "Markup_GrappleTargetPredicted";
        case 0x11A: return "Markup_CoverTargetType";
        case 0x11B: return "Markup_PotentialCoverTargetType";
        case 0x11C: return "Markup_Modifier";
        case 0x11D: return "Markup_ModifierJumpTarget";
        case 0x11E: return "Markup_ModifierGrappleJumpTarget";
        case 0x11F: return "Markup_ModifierGrapplePredictedTarget";
        case 0x120: return "Markup_ModifierEdge";
        case 0x121: return "Markup_ModifierCover";
        case 0x122: return "Markup_ModifierPotentialCover";
        case 0x123: return "Markup_Angle";
        case 0x124: return "Markup_LookaheadResult";
        case 0x125: return "Markup_LookaheadSegDistance";
        case 0x126: return "Markup_LookaheadVariableAngleTurnGreaterThan";
        case 0x127: return "Markup_LookaheadVariableAngleTurnLessThan";
        case 0x128: return "Markup_LookbehindSegDistance";
        case 0x129: return "Markup_ClearanceResult";
        case 0x12A: return "Markup_AttachState";
        case 0x12B: return "Markup_PotentialAttachState";
        case 0x12C: return "Markup_GrappleAttachState";
        case 0x12D: return "Markup_CoverAttachState";
        case 0x12E: return "Markup_SegDistanceLeft";
        case 0x12F: return "Markup_SegDistanceRight";
        case 0x130: return "Markup_ClippingAhead";
        case 0x131: return "Markup_ClippingBehind";
        case 0x132: return "Markup_DistanceToTarget";
        case 0x133: return "Markup_DistanceToTarget_Horizontal";
        case 0x134: return "Markup_DistanceToTarget_Vertical";
        case 0x135: return "Markup_DistanceToTarget_Forward";
        case 0x136: return "Markup_DistanceToTarget_Left";
        case 0x137: return "Markup_DistanceToTarget_Up";
        case 0x138: return "Markup_TimeToTarget";
        case 0x139: return "Markup_DistanceToCoverTarget";
        case 0x13A: return "Markup_DistanceToCoverTarget_Horizontal";
        case 0x13B: return "Markup_DistanceToCoverTarget_Vertical";
        case 0x13C: return "Markup_DistanceToCoverTarget_Forward";
        case 0x13D: return "Markup_DistanceToCoverTarget_Left";
        case 0x13E: return "Markup_DistanceToCoverTarget_Up";
        case 0x13F: return "Markup_TimeToCoverTarget";
        case 0x140: return "Markup_DistanceToPotentialCoverTarget";
        case 0x141: return "Markup_DistanceToPotentialCoverTarget_Horizontal";
        case 0x142: return "Markup_DistanceToPotentialCoverTarget_Vertical";
        case 0x143: return "Markup_DistanceToPotentialCoverTarget_Forward";
        case 0x144: return "Markup_DistanceToPotentialCoverTarget_Left";
        case 0x145: return "Markup_DistanceToPotentialCoverTarget_Up";
        case 0x146: return "Markup_TimeToPotentialCoverTarget";
        case 0x147: return "Markup_LastAttachedToTargetDistance";
        case 0x148: return "Markup_CoverToCoverStartToTargetDistance";
        case 0x149: return "Markup_HpoleRot_Equals";
        case 0x14A: return "Markup_HpoleRot_GreaterThan";
        case 0x14B: return "Markup_HpoleRot_LessThan";
        case 0x14C: return "Markup_Angle_Equals";
        case 0x14D: return "Markup_Angle_GreaterThan";
        case 0x14E: return "Markup_Angle_LessThan";
        case 0x14F: return "Markup_SlopeAngle_Equals";
        case 0x150: return "Markup_SlopeAngle_AtOrMore";
        case 0x151: return "Markup_SlopeAngle_AtOrLess";
        case 0x152: return "Markup_TipAngle_AtLeast";
        case 0x153: return "Markup_TipAngle_AtMost";
        case 0x154: return "Markup_TipAngleMagnitude_AtLeast";
        case 0x155: return "Markup_TipAngleMagnitude_AtMost";
        case 0x156: return "Markup_BoneAttachTarget";
        case 0x157: return "Markup_MoveDirection";
        case 0x158: return "Markup_CanAttachToJumpTarget";
        case 0x159: return "Markup_IsAttachedToMarkUp";
        case 0x15A: return "Markup_IsAttachedMarkUpEnabled";
        case 0x15B: return "Markup_IsDynamic";
        case 0x15C: return "Markup_IsZiplineSlippery";
        case 0x15D: return "Markup_JumpTargetSameAsAttached";
        case 0x15E: return "Markup_LadderCurrentRungLessThan";
        case 0x15F: return "Markup_SegmentLengthLessThan";
        case 0x160: return "Markup_IsAtMarkupCorner";
        case 0x161: return "Markup_IsAtMarkupCornerConcave";
        case 0x162: return "Markup_IsAtMarkupCornerConvex";
        case 0x163: return "Markup_CanPeekRightAtCurrentNode";
        case 0x164: return "Markup_CanPeekLeftAtCurrentNode";
        case 0x165: return "Markup_RNodeAttachDiff";
        case 0x166: return "Markup_HasSpecialStart";
        case 0x167: return "Markup_HasSpecialEnd";
        case 0x168: return "Markup_IsDFATargetOnLeftSideOfAttached";
        case 0x169: return "Markup_IsLimitingMovementOnAttach";
        case 0x16A: return "Markup_WallConcealmentHeadingLeft";
        case 0x16B: return "Markup_JumpTargetTag";
        case 0x16C: return "Markup_PotentialJumpTargetTag";
        case 0x16D: return "Markup_GrappleJumpTargetTag";
        case 0x16E: return "Markup_CoverJumpTargetTag";
        case 0x16F: return "Markup_AttachedMarkupTag";
        case 0x170: return "Markup_JumpTargetConcealmentType";
        case 0x171: return "Markup_PotentialJumpTargetConcealmentType";
        case 0x172: return "Markup_GrappleJumpTargetConcealmentType";
        case 0x173: return "Markup_CoverConcealmentType";
        case 0x174: return "Markup_PotentialCoverConcealmentType";
        case 0x175: return "Markup_AttachedMarkupConcealmentType";
        case 0x176: return "Markup_ConcealmentTargetConcealmentType";
        case 0x177: return "Markup_IsCombatMeleeTargetOnLeftOfCover";
        case 0x178: return "Markup_IsCombatMeleeTargetOnLeftOfAttachedMarkup";
        case 0x179: return "Markup_IsCombatMeleeTargetOnSameSideOfCover";
        case 0x17A: return "Markup_IsCombatMeleeTargetOnSameSideOfAttachedMarkup";
        case 0x17B: return "Paraglide_IsInCollisionState";
        case 0x17C: return "Grapple_IsAllowed";
        case 0x17D: return "Grapple_IsActive";
        case 0x17E: return "Grapple_IsAttached";
        case 0x17F: return "Grapple_IsRetracting";
        case 0x180: return "Grapple_IsPulling";
        case 0x181: return "Grapple_IsRappeling";
        case 0x182: return "Grapple_IsSwinging";
        case 0x183: return "Grapple_IsSlowingDown";
        case 0x184: return "Grapple_IsSupportValid";
        case 0x185: return "Grapple_IsWallValid";
        case 0x186: return "Grapple_IsBelowAttachPoint";
        case 0x187: return "Grapple_IsRopeGettingLonger";
        case 0x188: return "Grapple_GroundDetected";
        case 0x189: return "Grapple_WallDetected";
        case 0x18A: return "Grapple_WallLandDetected";
        case 0x18B: return "Grapple_SupportDetected";
        case 0x18C: return "Grapple_GroundLedgeDetected";
        case 0x18D: return "Grapple_WallLedgeDetected";
        case 0x18E: return "Grapple_LateralWallDetected";
        case 0x18F: return "Grapple_StepOnDetected";
        case 0x190: return "Grapple_OverhangDetected";
        case 0x191: return "Grapple_BarrierDetected";
        case 0x192: return "Grapple_FlailDetected";
        case 0x193: return "Grapple_PullAllowed";
        case 0x194: return "Grapple_AscendDescendAllowed";
        case 0x195: return "Grapple_SwingAllowed";
        case 0x196: return "Grapple_StruggleEnabled";
        case 0x197: return "Grapple_WasAttached";
        case 0x198: return "Grapple_SwingDirection";
        case 0x199: return "Grapple_RappelForceDirection";
        case 0x19A: return "Grapple_SwingForceDirection";
        case 0x19B: return "Grapple_VelocityDirection";
        case 0x19C: return "Grapple_RotationDirection";
        case 0x19D: return "Grapple_AscendDescendDirection";
        case 0x19E: return "Grapple_RappelSpeedGreaterThan";
        case 0x19F: return "Grapple_RopeAngleGreaterThan";
        case 0x1A0: return "Grapple_DistanceFromWallGreaterThan";
        case 0x1A1: return "Grapple_WallLandVelocityAngleGreaterThan";
        case 0x1A2: return "Grapple_HorizontalSpeedGreaterThan";
        case 0x1A3: return "Grapple_VerticalSpeedGreaterThan";
        case 0x1A4: return "Grapple_RopeLengthLessThanMinimum";
        case 0x1A5: return "Grapple_RopeLengthGreaterThanMaximum";
        case 0x1A6: return "Grapple_RappelSpeed";
        case 0x1A7: return "Grapple_RappelLateralSpeed";
        case 0x1A8: return "Grapple_RappelMesialSpeed";
        case 0x1A9: return "Grapple_RappelPosition";
        case 0x1AA: return "Grapple_RappelLeftForceDisabled";
        case 0x1AB: return "Grapple_RappelRightForceDisabled";
        case 0x1AC: return "Grapple_IsMainUser";
        case 0x1AD: return "Grapple_RopeSupportDetected";
        case 0x1AE: return "Grapple_GrappleGunAllowed";
        case 0x1AF: return "GrappleAxe_Allowed";
        case 0x1B0: return "GrappleAxe_SwingFinished";
        case 0x1B1: return "GrappleAxe_DetachOnCollision";
        case 0x1B2: return "GrappleAxeSwing_Attached";
        case 0x1B3: return "GrappleAxeSwing_AutoJumpoff";
        case 0x1B4: return "GrappleAxeClimb_Attached";
        case 0x1B5: return "GrappleAxeClimb_Finished";
        case 0x1B6: return "GrappleAxeClimb_AtTop";
        case 0x1B7: return "GrappleAxeClimb_AtBottom";
        case 0x1B8: return "GrappleAxeClimb_GroundProbeCollidesNonFlooring";
        case 0x1B9: return "GrappleAxeClimb_UpDownFinished";
        case 0x1BA: return "GrappleAxeClimb_IsUsingAutoClimb";
        case 0x1BB: return "GrappleAxeClimb_AtBracedWallLimit";
        case 0x1BC: return "GrappleAxeClimb_NearTopUndetectedWallCrawl";
        case 0x1BD: return "GrappleAxeClimb_Braced";
        case 0x1BE: return "GrappleAxeWall_Attached";
        case 0x1BF: return "GrappleAxe_AxeRecovered";
        case 0x1C0: return "GrappleAxeSwing_ArrowSwing";
        case 0x1C1: return "GrappleAxeClimb_WallRunning";
        case 0x1C2: return "GrappleAxeClimb_WallRunFromRest";
        case 0x1C3: return "GrappleAxeClimb_WallRunIsInRest";
        case 0x1C4: return "GrappleAxeClimb_WallRunCanInitiateMoveDownQuick";
        case 0x1C5: return "GrappleAxeClimb_WallRunIsInHoldPosition";
        case 0x1C6: return "GrappleAxeClimb_WallRunCanInitiateHoldPosition";
        case 0x1C7: return "GrappleAxeClimb_WallRunStickAngleInUpDownRange";
        case 0x1C8: return "GrappleAxeClimb_RappelSwingIsActive";
        case 0x1C9: return "GrappleAxeClimb_RappelSwingInRestRange";
        case 0x1CA: return "GrappleAxeClimb_RappelButtonHoldingRequiredToClimbUpDown";
        case 0x1CB: return "GrappleAxeClimb_RappelIsInClimbMode";
        case 0x1CC: return "Water_VolumeDepth";
        case 0x1CD: return "Water_VolumeDepthAtMost";
        case 0x1CE: return "Water_VolumeDepthAtLeast";
        case 0x1CF: return "Water_VolumeDepth_cm";
        case 0x1D0: return "Water_SwimDepth";
        case 0x1D1: return "Water_SwimDepthAtMost";
        case 0x1D2: return "Water_SwimDepthAtLeast";
        case 0x1D3: return "Water_SwimDepth_cm";
        case 0x1D4: return "Water_SwimDepth_TimeSinceChange";
        case 0x1D5: return "Water_NoColToSurface";
        case 0x1D6: return "Water_SurfaceAirLevel";
        case 0x1D7: return "Water_SurfaceAirLevelAtMost";
        case 0x1D8: return "Water_SurfaceAirLevelAtLeast";
        case 0x1D9: return "Water_SurfaceAirLevel_cm";
        case 0x1DA: return "Water_EntityApplyForces";
        case 0x1DB: return "Water_EntityApplyEffects";
        case 0x1DC: return "Water_Current";
        case 0x1DD: return "Water_IsInStrongCurrent";
        case 0x1DE: return "Water_IsInStrongCurrent_RadiusOffset";
        case 0x1DF: return "Water_StrongCurrent_EvaluateCollisionType";
        case 0x1E0: return "Water_CurrentSpeedAtMost";
        case 0x1E1: return "Water_CurrentSpeedAtLeast";
        case 0x1E2: return "Water_Waves";
        case 0x1E3: return "Water_WaveHeightAtMost";
        case 0x1E4: return "Water_WaveHeightAtLeast";
        case 0x1E5: return "Water_WaterInFrontAndBelow";
        case 0x1E6: return "Water_SwimCombatExtremeAngleTrans";
        case 0x1E7: return "Water_LedgeCloseToSurface";
        case 0x1E8: return "Gameplay_BBeamHandsOverlayAllowed";
        case 0x1E9: return "Gameplay_LockIntoNonInteractiveState";
        case 0x1EA: return "Gameplay_LockIntoHostedInteractiveSequence";
        case 0x1EB: return "Gameplay_Notification";
        case 0x1EC: return "Gameplay_TimeSinceMantleOrHurdleMounted";
        case 0x1ED: return "Gameplay_TimeSinceMantleOrHurdleCanceled";
        case 0x1EE: return "Gameplay_TimeSinceMarkupAttach";
        case 0x1EF: return "Gameplay_TimeSinceSameMarkupAttach";
        case 0x1F0: return "Gameplay_TimeSinceSameMarkupDetach";
        case 0x1F1: return "Character_Stance";
        case 0x1F2: return "Combat_LockOnAllowed";
        case 0x1F3: return "Combat_CombatAllowed";
        case 0x1F4: return "Combat_PostCombatAllowed";
        case 0x1F5: return "Combat_DualGunsAllowed";
        case 0x1F6: return "Combat_InventoryPause";
        case 0x1F7: return "Combat_GearAllowed";
        case 0x1F8: return "Combat_WeaponInHand";
        case 0x1F9: return "Combat_ReactiveDodgeWindow";
        case 0x1FA: return "Combat_CombatTurnDone";
        case 0x1FB: return "Combat_ShouldUseAimCamera";
        case 0x1FC: return "Combat_AimCamZoomAllowed";
        case 0x1FD: return "Combat_AimCamSwitchAllowed";
        case 0x1FE: return "Combat_IsAimCamZoomed";
        case 0x1FF: return "Combat_IsAimCamZoomedLevel2";
        case 0x200: return "Combat_IsAimCamSwitched";
        case 0x201: return "Combat_IsInRangedState";
        case 0x202: return "Combat_IsInSwitchWeaponState";
        case 0x203: return "Combat_IsInMeleeFollowthroughState";
        case 0x204: return "Combat_IsInRangedDodgeState";
        case 0x205: return "Combat_IsInTurretState";
        case 0x206: return "Combat_RangedMoveActive";
        case 0x207: return "Combat_AimIsOnEnemy";
        case 0x208: return "Combat_InCombatLock";
        case 0x209: return "Combat_PortableThrow";
        case 0x20A: return "Combat_LastTargetOnLeft";
        case 0x20B: return "Combat_BinocularsAllowed";
        case 0x20C: return "Combat_PrimaryOverrideVar";
        case 0x20D: return "Combat_InForcedAimState";
        case 0x20E: return "Status_InThrownOrLandingState";
        case 0x20F: return "Combat_ReactiveDodgeVar";
        case 0x210: return "Combat_InDodge";
        case 0x211: return "Combat_FireWeapon";
        case 0x212: return "Combat_PostCombatFireWeapon";
        case 0x213: return "Combat_FireTurretAllowed";
        case 0x214: return "Combat_LastTargetOnRight";
        case 0x215: return "Combat_UnequipItemInInvPause";
        case 0x216: return "Combat_InCounterAllowedWindow";
        case 0x217: return "Combat_InInterruptAllowedWindow";
        case 0x218: return "Combat_PlayerToPrimTargAngWithZAtLeast";
        case 0x219: return "Combat_PlayerToPrimTargAngWithZAtMost";
        case 0x21A: return "Combat_PlayerToPrimTargAngWithZMagAtLeast";
        case 0x21B: return "Combat_PlayerToPrimTargAngWithZMagAtMost";
        case 0x21C: return "Combat_PlayerPassedThruPrimTargetPlane";
        case 0x21D: return "Combat_IsOffensiveCollisionOn";
        case 0x21E: return "Combat_IsOffensiveCollisionOnOrPostWindow";
        case 0x21F: return "Combat_NumFramesTillOffensiveCollisionOn";
        case 0x220: return "Combat_NumFramesAfterOffensiveCollisionOff";
        case 0x221: return "Combat_OneWeaponInHand";
        case 0x222: return "Combat_WeaponEquipped";
        case 0x223: return "Combat_TargetAcquired";
        case 0x224: return "Combat_TargetAimAllowed";
        case 0x225: return "Combat_TargetIsBehindPlayer";
        case 0x226: return "Combat_MeleeTargetIsFinishable";
        case 0x227: return "Combat_MeleeTargetIsHelmetShatterArmorIntact";
        case 0x228: return "Combat_MeleeTargetIsStealthKillable";
        case 0x229: return "Combat_MeleeTargetIsChargeKillable";
        case 0x22A: return "Combat_MeleeTargetIsInaccessible";
        case 0x22B: return "Combat_MeleeTargetIsInteracting";
        case 0x22C: return "Combat_MeleeTargetIsNpc";
        case 0x22D: return "Combat_MeleeTargetIsFinishersDisabled";
        case 0x22E: return "Combat_DeathFromAboveTargetIsFinishersDisabled";
        case 0x22F: return "Combat_MeleeTargetIsRequirementsSatisfied";
        case 0x230: return "Combat_MeleeTargetIsRequirementsSatisfiedAllowPrevious";
        case 0x231: return "Combat_MeleeTargetSecondaryIsRequirementsSatisfied";
        case 0x232: return "Combat_MeleeTargetSecondaryIsRequirementsSatisfiedAllowPrevious";
        case 0x233: return "Combat_DeathFromAboveTargetIsRequirementsSatisfied";
        case 0x234: return "Combat_MeleeMove";
        case 0x235: return "Combat_MeleeTargetIsStunnedKnees";
        case 0x236: return "Combat_MeleeTargetIsStunnedProne";
        case 0x237: return "Combat_MeleeTargetIsStumbled";
        case 0x238: return "Combat_MeleeTargetHealthGT";
        case 0x239: return "Combat_MeleeTargetPlayerIsInSustainInjuryHealthStateForMoreThanOneFrame";
        case 0x23A: return "Combat_MeleeTargetIsObject";
        case 0x23B: return "Combat_DeathFromAboveTargetIsObject";
        case 0x23C: return "Combat_ContextKillAttacker";
        case 0x23D: return "Combat_ContextKillDefender";
        case 0x23E: return "Combat_MeleeTargetIsOffensiveCollisionOn";
        case 0x23F: return "Combat_MeleeTargetNumFramesTillOffensiveCollisionOn";
        case 0x240: return "Combat_MeleeTargetInCounterAllowedWindow";
        case 0x241: return "Combat_MeleeAttackedHasBeenCountered";
        case 0x242: return "Combat_MeleeTargetHasNoOffensiveCollisionProp";
        case 0x243: return "Combat_MeleeTargetIsStunnedFromDeathFromAbove";
        case 0x244: return "Combat_MeleeTargetIsAwareOfMe";
        case 0x245: return "Combat_MeleeTargetIsInFinisherWOOByFrames";
        case 0x246: return "Combat_SecondaryMeleeTargetIsInFinisherWOOByFrames";
        case 0x247: return "Combat_DeathFromAboveTargetIsAwareOfMe";
        case 0x248: return "Combat_DeathFromAboveTargetIsInFinisherWOOByFrames";
        case 0x249: return "Combat_HasNetMeleeTarget";
        case 0x24A: return "Combat_MeleeTargetFartherThanMaxLungeDist";
        case 0x24B: return "Combat_LastMeleeContactIsSeizeDeny";
        case 0x24C: return "Combat_LastMeleeContactIsNpc";
        case 0x24D: return "Combat_LastMeleeContactIsDifferentFromPrev";
        case 0x24E: return "Combat_LastMeleeContactIsSeizeDefendAllowed";
        case 0x24F: return "Combat_LastMeleeContactIsDifferentFromMeleeTarget";
        case 0x250: return "Combat_PrimaryTargetIsWithinRange";
        case 0x251: return "Combat_CurrentWeaponLastAmmo";
        case 0x252: return "Combat_InteractedWeaponLastAmmo";
        case 0x253: return "Combat_CurrentWeaponNoAmmo";
        case 0x254: return "Combat_InteractedWeaponNoAmmo";
        case 0x255: return "Combat_CurrentWeaponFullAmmo";
        case 0x256: return "Combat_CurrentWeaponInfiniteAmmo";
        case 0x257: return "Combat_CurrentWeaponIsOverHeat";
        case 0x258: return "Combat_CurrentWeaponIsStowedOrAway";
        case 0x259: return "Combat_MultiplayerProjectileIsReady";
        case 0x25A: return "Combat_InteractedWeaponIsOverHeat";
        case 0x25B: return "Combat_CurrentWeaponBurstFireReady";
        case 0x25C: return "Combat_CurrentWeaponAltBurstFireReady";
        case 0x25D: return "Combat_CurrentWeaponFullOrInsufficientForFullClip";
        case 0x25E: return "Combat_UIChosenWeaponFullOrInsufficientForFullClip";
        case 0x25F: return "Combat_UIChosenWeaponPlayerNoAmmo";
        case 0x260: return "Combat_UIChosenWeaponPlayerNoAltAmmo";
        case 0x261: return "Combat_PlayerNoAmmo";
        case 0x262: return "Combat_InteractedWeaponStockpileNoAmmo";
        case 0x263: return "Combat_PlayerNoAltAmmo";
        case 0x264: return "Combat_InteractedWeaponStockpileNoAltAmmo";
        case 0x265: return "Combat_CurrentWeaponNoAltAmmo";
        case 0x266: return "Combat_InteractedWeaponNoAltAmmo";
        case 0x267: return "Combat_CurrentWeapon_FireMode";
        case 0x268: return "Combat_CurrentWeapon_Alt_FireMode";
        case 0x269: return "Combat_InteractedWeapon_FireMode";
        case 0x26A: return "Combat_InteractedWeapon_Alt_FireMode";
        case 0x26B: return "Combat_CurrentWeapon_HasAltFire";
        case 0x26C: return "Combat_CurrentWeapon_IsUsable";
        case 0x26D: return "Combat_CurrentWeapon_HasTrait";
        case 0x26E: return "Combat_CurrentWeapon_InventoryStateNoProcess";
        case 0x26F: return "Combat_RangedTargetPassesFriendlyFireRules";
        case 0x270: return "Combat_TargetIsMeleeing";
        case 0x271: return "Combat_CameraAngleToLockedTarget_LessThan";
        case 0x272: return "Combat_CameraAngleToLockedTarget_MoreThan";
        case 0x273: return "Combat_CameraAngleToLockedTarget_MagLessThan";
        case 0x274: return "Combat_CameraAngleToLockedTarget_MagMoreThan";
        case 0x275: return "Combat_TR9PrototypeMelee_RadialStickFlick";
        case 0x276: return "Combat_TR9PrototypeMelee_ChordStickFlick";
        case 0x277: return "Combat_TR9PrototypeMelee_CircleStickFlick";
        case 0x278: return "Combat_TR9PrototypeMelee_RadialStickFlickDir";
        case 0x279: return "Combat_TR9PrototypeMelee_ChordStickFlickDir";
        case 0x27A: return "Combat_TR9PrototypeMelee_TargetZoneArmored";
        case 0x27B: return "Combat_TR9PrototypeMelee_IsStickInPainZone";
        case 0x27C: return "Combat_TR9PrototypeMelee_IsCircleStickFlickClockwise";
        case 0x27D: return "Combat_TR9Prototype_IsTargetTrapped";
        case 0x27E: return "Combat_NewCombo";
        case 0x27F: return "Combat_AnimType";
        case 0x280: return "Combat_HoldBlock";
        case 0x281: return "Combat_HasOnScreenEnemiesOppositeCover";
        case 0x282: return "Combat_AimKickBack_Remaining";
        case 0x283: return "Combat_HasTrapTarget";
        case 0x284: return "Combat_TrapTargetWithin";
        case 0x285: return "Cover_EnterDirection";
        case 0x286: return "Cover_PeekDirection";
        case 0x287: return "Cover_TargetDirection";
        case 0x288: return "Gameplay_InSprint";
        case 0x289: return "Combat_Cover_NearLeftEdge";
        case 0x28A: return "Combat_CanAttackStun";
        case 0x28B: return "Combat_IsPlayerCombatStatus";
        case 0x28C: return "Combat_IsCamouflageAllowed";
        case 0x28D: return "Combat_LastDamageInflicter_IsInMeleeStepNumber";
        case 0x28E: return "Combat_PlayerCombatStatus_ShouldArmWeapon";
        case 0x28F: return "Combat_IsInMeleeStepNumber";
        case 0x290: return "Combat_CanRapidFire";
        case 0x291: return "Combat_CanRapidFireAlt";
        case 0x292: return "Combat_IsHelpless";
        case 0x293: return "Combat_InRapidFire";
        case 0x294: return "Combat_FiredThisFrame";
        case 0x295: return "Combat_IsInVegetationCutStepNumber";
        case 0x296: return "Combat_IsInVegetationCut";
        case 0x297: return "Combat_AccumulatedDamageAtOrMore";
        case 0x298: return "UseObjectState";
        case 0x299: return "UseObjectReaction";
        case 0x29A: return "Npc_InvestigationTargetHadLOS";
        case 0x29B: return "Npc_MoverIsJumping";
        case 0x29C: return "Npc_MoverIsTurning";
        case 0x29D: return "Npc_MoverAnimatedReorientationInfoGenerated";
        case 0x29E: return "Npc_IsAnimTurning";
        case 0x29F: return "Npc_CheckCircleFit";
        case 0x2A0: return "Npc_CheckCircleFitLeft";
        case 0x2A1: return "Npc_CheckCircleFitHalfLeft";
        case 0x2A2: return "Npc_CheckCircleFitRight";
        case 0x2A3: return "Npc_CheckCircleFitHalfRight";
        case 0x2A4: return "Npc_GoalComplete";
        case 0x2A5: return "Npc_AnimGoalComplete";
        case 0x2A6: return "Npc_ActionStatus";
        case 0x2A7: return "Npc_HasMarkupJumpTarget";
        case 0x2A8: return "Npc_IsAttachedToMarkup";
        case 0x2A9: return "Npc_IsNearNavHelperDestination";
        case 0x2AA: return "Npc_IsNavHelperTraversalComplete";
        case 0x2AB: return "Npc_IsMarkupSegmentTraversalComplete";
        case 0x2AC: return "Npc_HasProjectileAttached";
        case 0x2AD: return "Npc_PuppetModeOver";
        case 0x2AE: return "Npc_ProcessRequested";
        case 0x2AF: return "Npc_IsSideStepBlocked";
        case 0x2B0: return "Npc_ShouldDoAnimatedTurn";
        case 0x2B1: return "Npc_ShouldDoAnimatedStart";
        case 0x2B2: return "Npc_TestIsProne";
        case 0x2B3: return "Npc_IsStunnedKnees";
        case 0x2B4: return "Npc_IsStunnedProne";
        case 0x2B5: return "Npc_IsStumbled";
        case 0x2B6: return "IsJumpTimerActive";
        case 0x2B7: return "Npc_ThreatMood";
        case 0x2B8: return "Npc_IsSenseAwareOfAnyPlayer";
        case 0x2B9: return "Npc_IsAwareOfPlayer";
        case 0x2BA: return "Combat_IsInContextKill";
        case 0x2BB: return "Combat_ContextKillHasStarted";
        case 0x2BC: return "InvestigateTargetType";
        case 0x2BD: return "Physics_GravityProbeHit";
        case 0x2BE: return "Physics_GravityProbing";
        case 0x2BF: return "Physics_SpatialProbeTest";
        case 0x2C0: return "Physics_SpatialProbeHit";
        case 0x2C1: return "Physics_SpatialProbeHit_Distance";
        case 0x2C2: return "Physics_SpatialProbeHit_Mass";
        case 0x2C3: return "Physics_SpatialProbeHit_Type";
        case 0x2C4: return "Physics_SpatialProbeHit_CloserThanThisOne";
        case 0x2C5: return "Physics_SpatialProbeHit_ToSurfaceNormalAngleLTE";
        case 0x2C6: return "Physics_SpatialProbeHit_ToSurfaceNormalAngleGTE";
        case 0x2C7: return "Physics_ExplosionForceGTE";
        case 0x2C8: return "CanEngage";
        case 0x2C9: return "HasRequiredItem";
        case 0x2CA: return "IsInsertLocationHigh";
        case 0x2CB: return "ReachedAlignmentDestination";
        case 0x2CC: return "ReachedAlignmentRotation";
        case 0x2CD: return "EngageDone";
        case 0x2CE: return "HasActivatedEngage";
        case 0x2CF: return "IsInteractUsingHostedAnimGraph";
        case 0x2D0: return "CanInteract";
        case 0x2D1: return "Interact_IsHeldPortable";
        case 0x2D2: return "InteractSkipsRequest";
        case 0x2D3: return "InteractEndsInstantly";
        case 0x2D4: return "InteractComplete";
        case 0x2D5: return "InteractCancel";
        case 0x2D6: return "ForceInteractStartValid";
        case 0x2D7: return "ForceInteractEndValid";
        case 0x2D8: return "CanAdvertise";
        case 0x2D9: return "CanContextKill";
        case 0x2DA: return "CanContextKillObj";
        case 0x2DB: return "CanContextKillShove";
        case 0x2DC: return "CanContextKillCounter";
        case 0x2DD: return "IsStillTargetOfInteract";
        case 0x2DE: return "IsStillHostingInteract";
        case 0x2DF: return "Interacted_IsWeapon";
        case 0x2E0: return "Interacted_IsInstantInteractionObject";
        case 0x2E1: return "Interacted_IsAnotherPlayer";
        case 0x2E2: return "Interacted_IsPlayerAgent";
        case 0x2E3: return "Interacted_IsPlayerAssassin";
        case 0x2E4: return "Interacted_IsPlayerEngineer";
        case 0x2E5: return "Interacted_IsPlayerThief";
        case 0x2E6: return "Interacted_IsInteractableType";
        case 0x2E7: return "Interacted_IsStateModeType";
        case 0x2E8: return "Interacted_IsStateEndModeType";
        case 0x2E9: return "Interacted_UseUpdateMarkUpAttachSplineTFromMarkUpBone";
        case 0x2EA: return "Interacted_CheckInteractButtonless";
        case 0x2EB: return "Interacted_IsUsingTurretAttachmentAction";
        case 0x2EC: return "Interacted_IsInteractionValid";
        case 0x2ED: return "Interacted_IsInvulnerable";
        case 0x2EE: return "Interacted_IsPushPull";
        case 0x2EF: return "Interacted_IsCurrentRopeTarget";
        case 0x2F0: return "Interacted_KeepWeaponInHand";
        case 0x2F1: return "Interacted_IsMovingInteract";
        case 0x2F2: return "Interacted_IsInteracting";
        case 0x2F3: return "Interacted_CanHitReact";
        case 0x2F4: return "Interacted_IsPortablePickup";
        case 0x2F5: return "Interacted_UseObject";
        case 0x2F6: return "EngagedObjectType";
        case 0x2F7: return "PushPull_MustDetach";
        case 0x2F8: return "PushPull_ObjectHasVelocity";
        case 0x2F9: return "Portable_IsHolding";
        case 0x2FA: return "Portable_IsHoldingMainhand";
        case 0x2FB: return "Portable_IsHoldingOffhand";
        case 0x2FC: return "Portable_IsTwoHanded";
        case 0x2FD: return "Portable_IsPickupAllowed";
        case 0x2FE: return "Portable_IsTwoHandedAllowed";
        case 0x2FF: return "Portable_IsQuickThrow";
        case 0x300: return "Portable_IsThrowAiming";
        case 0x301: return "Portable_IsThrowAllowed";
        case 0x302: return "Portable_IsFlammable";
        case 0x303: return "Portable_IsPreventingJump";
        case 0x304: return "Portable_IsWeapon";
        case 0x305: return "Portable_IsMeleeWeapon";
        case 0x306: return "Portable_IsOnFire";
        case 0x307: return "Portable_IsThrowable";
        case 0x308: return "Portable_ShouldUseActiveAnimation";
        case 0x309: return "Portable_CriticalSection";
        case 0x30A: return "Portable_IsInUse";
        case 0x30B: return "Portable_DisallowThrowAtInvalidLocation";
        case 0x30C: return "PortableAnimType_IsAvailable";
        case 0x30D: return "PortableAnimType_IsAvailableEngagedInst";
        case 0x30E: return "PortableUsageType_Current";
        case 0x30F: return "PortableUsageType_Thrown";
        case 0x310: return "MeleeAllowed";
        case 0x311: return "MeleeChargeAllowed";
        case 0x312: return "MeleeIsActive";
        case 0x313: return "MeleeMoveInProgress";
        case 0x314: return "MeleeTargetSensed";
        case 0x315: return "MeleeTargetDir";
        case 0x316: return "MeleeTargetHeight";
        case 0x317: return "MeleeVaultAllowed";
        case 0x318: return "RangedTargetSensed";
        case 0x319: return "DeathFromAboveTargetSensed";
        case 0x31A: return "DeathFromAboveTargetSensedAllowPrevious";
        case 0x31B: return "Inventory_HasAmmo";
        case 0x31C: return "Inventory_IsAvailable";
        case 0x31D: return "Inventory_HasItem";
        case 0x31E: return "Inventory_IsActive";
        case 0x31F: return "Inventory_IsReady";
        case 0x320: return "Inventory_IsCurrentItem";
        case 0x321: return "Inventory_IsCurrentItemTypeCompatible";
        case 0x322: return "Inventory_IsLocked";
        case 0x323: return "Inventory_IsCurrentOrUIChosenItem_RangedWeapon";
        case 0x324: return "Inventory_IsCurrentItem_RangedWeapon";
        case 0x325: return "Inventory_IsUIChosenItem_RangedWeapon";
        case 0x326: return "Inventory_IsUIChosenWeapon";
        case 0x327: return "Inventory_IsUIChosenWeaponSelectDisabled";
        case 0x328: return "Inventory_IsUIChosenWeaponChanged";
        case 0x329: return "Inventory_IsUIChosenWeaponAmmoChanged";
        case 0x32A: return "Inventory_IsUIChosenWeaponLocked";
        case 0x32B: return "Inventory_IsResourceAvailable";
        case 0x32C: return "StateControl_IsStateTag";
        case 0x32D: return "Status_IsAdrenalineActive";
        case 0x32E: return "Status_IsAdrenalineReady";
        case 0x32F: return "Status_InvGearUse";
        case 0x330: return "Status_InOneHandedCombat";
        case 0x331: return "Status_InvStateTimerElapsed";
        case 0x332: return "Status_InvUsingLeft";
        case 0x333: return "Status_InvNeedReload";
        case 0x334: return "Status_InvNeedWeaponChange";
        case 0x335: return "Status_CombatLockTimerElapsed";
        case 0x336: return "Status_InvHammerUse";
        case 0x337: return "Status_InvHasWeapon";
        case 0x338: return "Status_IsTorchHeld";
        case 0x339: return "Status_IsTorchLit";
        case 0x33A: return "Status_IsTorchUseAllowed";
        case 0x33B: return "Status_IsRagdollActive";
        case 0x33C: return "Status_IsCraftingAllowed";
        case 0x33D: return "Status_IsCraftingInProgress";
        case 0x33E: return "Status_IsCraftingActive";
        case 0x33F: return "Crafting_IsRecipeCraftable";
        case 0x340: return "Crafting_AreRecipeTraitsMet";
        case 0x341: return "Crafting_IsHerbCurrentlySelected";
        case 0x342: return "Crafting_ActiveHerbDurationElapsed";
        case 0x343: return "Crafting_ActiveHerbDelaying";
        case 0x344: return "Crafting_MobileHerbAllowed";
        case 0x345: return "Damaged_IsDamageType";
        case 0x346: return "Damaged_IsRapidFireCombo";
        case 0x347: return "Damaged_IsHitReactType";
        case 0x348: return "Damaged_AmountGreaterThan";
        case 0x349: return "Damaged_AccumulatedAmountGreaterThan";
        case 0x34A: return "Damaged_AmountGreaterThanMaxHealthPercent";
        case 0x34B: return "Damaged_AccumulatedAmountGreaterThanMaxHealthPercent";
        case 0x34C: return "Damaged_DamagedHPrimNum";
        case 0x34D: return "Damaged_IsDamageNoKillActivated";
        case 0x34E: return "Damaged_IsHitShapeType";
        case 0x34F: return "Damaged_IsBallisticDamage";
        case 0x350: return "Damaged_IsMeleeTargetDamageType";
        case 0x351: return "Damaged_IsMeleeTargetHitReactType";
        case 0x352: return "Damaged_IsLastMeleeContactDamageType";
        case 0x353: return "Damaged_IsLastMeleeContactHitReactType";
        case 0x354: return "Health_HealthAmountGreaterThan";
        case 0x355: return "Health_HealthPercentGreaterThan";
        case 0x356: return "Health_FramesSinceDamaged";
        case 0x357: return "Health_FramesSinceDamaged_OnMarkup";
        case 0x358: return "Health_BreathPercent";
        case 0x359: return "Health_BreathPercentAtLeast";
        case 0x35A: return "Health_BreathPercentAtMost";
        case 0x35B: return "Npc_AimEvadeHPrimNum";
        case 0x35C: return "Npc_AimEvadeAngle_EqualOrLess";
        case 0x35D: return "Npc_AimEvadeAngle_EqualOrGreater";
        case 0x35E: return "Npc_AngleToTarget_Whitin";
        case 0x35F: return "Process_DestroyPortable";
        case 0x360: return "Process_DropPortable";
        case 0x361: return "Process_DropPortable_MainHand";
        case 0x362: return "Process_DropPortable_OffHand";
        case 0x363: return "Process_DropPortable_IgnoreOwnerVelocity";
        case 0x364: return "Process_DropPortable_IgnoreOwnerVelocity_OffHand";
        case 0x365: return "Process_OverlayStumble";
        case 0x366: return "Process_MarkupDetach";
        case 0x367: return "Process_ClearJumpTarget";
        case 0x368: return "Process_AutoCameraOverride";
        case 0x369: return "Process_RecordEventTime";
        case 0x36A: return "Process_InventoryUpdateUIChosenWeapon";
        case 0x36B: return "Process_NegativeResponse";
        case 0x36C: return "Process_AnimGraph_TriggerEvent";
        case 0x36D: return "Process_Inventory_SetUIChosenWeapon";
        case 0x36E: return "Process_Inventory_StoreCurrentUIChosenWeapon";
        case 0x36F: return "Process_ChangeWeaponLoadoutIfNeeded";
        case 0x370: return "Development_Identity";
        case 0x371: return "Development_Prototype";
        case 0x372: return "NamedValue_Boolean";
        case 0x373: return "NamedValue_Scalar_EQ";
        case 0x374: return "NamedValue_Scalar_GT";
        case 0x375: return "NamedValue_Scalar_GTE";
        case 0x376: return "NamedValue_Symbol_Comp";
        case 0x377: return "Combat_DistanceToTargetGreaterThan";
        case 0x378: return "Combat_HeightToTargetGreaterThan";
        case 0x379: return "Combat_AngleToTargetGreaterThan";
        case 0x37A: return "Combat_I_Am_MeleeTarget_Of_LastDamageInflicter";
        case 0x37B: return "Combat_I_Am_MeleeTarget_Of_MyMeleeTarget";
        case 0x37C: return "Combat_Seize_IsEngaged";
        case 0x37D: return "Combat_Seize_IsAttacker";
        case 0x37E: return "Combat_Seize_AttackAllowed";
        case 0x37F: return "Combat_MeleeSenses_IsTargetSeizable";
        case 0x380: return "Combat_MeleeSenses_IsTargetInSeizeAlready";
        case 0x381: return "Physics_SpatialProbe_IsTargetSeizable";
        case 0x382: return "Combat_Seize_IsMeterGoalReached";
        case 0x383: return "Combat_Seize_IsMeterGoalFailed";
        case 0x384: return "Combat_Seize_IsMeterTimeoutSuccess";
        case 0x385: return "Combat_Seize_IsMeterTimeoutFail";
        case 0x386: return "Combat_Seize_IsMeterTimeoutNoWinner";
        case 0x387: return "Combat_Seize_IsFailDamageResultsDeath";
        case 0x388: return "Combat_Seize_IsOnStartDamageResultsDeath";
        case 0x389: return "Combat_Seize_IsPairedInstanceOnStartDamageResultsDeath";
        case 0x38A: return "Combat_Seize_IsTargetInTrap";
        case 0x38B: return "Combat_AttackShotIsQueued";
        case 0x38C: return "Combat_IsStuckInTrap";
        case 0x38D: return "Combat_IsJumpEscapeInProgress";
        case 0x38E: return "Combat_CameraAutoSwitchLeft";
        case 0x38F: return "Combat_CameraAutoSwitchRight";
        case 0x390: return "Combat_IsUsingFinisher";
        case 0x391: return "Seize_IsTargetPassSeizeRequirements";
        case 0x392: return "Physics_SpatialProbe_IsTargetPassSeizeRequirements";
        case 0x393: return "Seize_IsCurrentSeizeAttack";
        case 0x394: return "Seize_IsGivenProbeHitInstanceSeizable";
        case 0x395: return "Combat_HardCodedProbeToMeleeTargetClear";
        case 0x396: return "Experience_PlayerTrait";
        case 0x397: return "Experience_TargetPlayerTrait";
        case 0x398: return "Multiplayer_PlayerIsAllowedToRespawn";
        case 0x399: return "Multiplayer_PlayerCanBeRevived";
        case 0x39A: return "Multiplayer_PlayerIsAllowedToGetUp";
        case 0x39B: return "Multiplayer_SomePlayerInProneState";
        case 0x39C: return "Multiplayer_PlayerDoneReviving";
        case 0x39D: return "Multiplayer_PlayerIsBeingRevived";
        case 0x39E: return "Multiplayer_IsProne";
        case 0x39F: return "Multiplayer_IsBeingExecuted";
        case 0x3A0: return "Multiplayer_IsRequestingFinisher";
        case 0x3A1: return "Multiplayer_SyncronizedFinisherKickedOff";
        case 0x3A2: return "Multiplayer_IsDelayDeath";
        case 0x3A3: return "Multiplayer_PlayerProximityTestForMarkup";
        case 0x3A4: return "Multiplayer_CanPlayerFinish";
        case 0x3A5: return "Multiplayer_CanTransitionToFinisherVictim";
        case 0x3A6: return "Multiplayer_CanTargetStillBeFinished";
        case 0x3A7: return "Multiplayer_IsMultiplayer";
        case 0x3A8: return "Multiplayer_IsAuthoritativeOnHost";
        case 0x3A9: return "GameMode_IsMode";
        case 0x3AA: return "Status_InSlopeState";
        case 0x3AB: return "Status_InSlopeForcedStumbleState";
        case 0x3AC: return "Status_InEvadeState";
        case 0x3AD: return "Weapon_IsLoadoutType";
        case 0x3AE: return "Weapon_IsLoadoutTypeOfLastProjectileFired";
        case 0x3AF: return "CameraCategory_IsCategoryEnabled";
        case 0x3B0: return "Instance_IsObject";
        case 0x3B1: return "Combat_SeizePartnerIsObject";
        case 0x3B2: return "PROTOTYPE_UseFluidCover";
        case 0x3B3: return "Weather_IsWeatherTypeActive";
        case 0x3B4: return "Awareness_StumbleActionRequestedWithinWatchWindow";
        case 0x3B5: return "Combat_FlairMoveAllowed";
        case 0x3B6: return "Combat_SelectedFlairMove";
        case 0x3B7: return "Combat_TR9PrototypeMeleeStarted";
        case 0x3B8: return "Combat_MeleeTargetIsAwareOfMeForMoreThanGivenTimeSec";
        case 0x3B9: return "Pressed";
        case 0x3BA: return "Released";
        case 0x3BB: return "NewlyPressed";
        case 0x3BC: return "NewlyReleased";
        case 0x3BD: return "Move_Zone";
        case 0x3BE: return "Markup_HaveDICESwingTarget";
        case 0x3BF: return "EdgeDet_DropType";
        case 0x3C0: return "EdgeDet_DropTypeOld";
        case 0x3C1: return "EdgeDet_DropRule";
        case 0x3C2: return "EdgeDet_DropRuleOld";
        case 0x3C3: return "EdgeDet_StepRule";
        case 0x3C4: return "EdgeDet_StepRuleOld";
        case 0x3C5: return "EdgeDet_WallCrawl";
        case 0x3C6: return "Status_IsMouseKeyboard";
        case 0x3C7: return "Code_DebugAssertHelper";
        case 0x3C8: return "Platform";
        case 0x3C9: return "VrMode";
        default: return Str("%d", condition);
    }
}
